# 压力测试结果对比

测试时间: 2026-01-17
测试环境: Windows 本地开发机 + Docker (PostgreSQL, Kafka, Redis)

## 测试配置

- **跳转测试**: 50 并发用户，持续 1 分钟
- **综合测试**: 最高 100 并发用户，2 分 20 秒（阶段式加压）

---

## 跳转性能对比 (GET /:code)

| 指标 | Channel 模式 | Kafka 模式 | 差异 |
|------|-------------|-----------|------|
| **QPS** | 6,305 | 6,689 | +6% |
| **总请求数** | 379,444 | 402,261 | +6% |
| **平均延迟** | 7.58ms | 7.21ms | -5% |
| **P50** | 6.82ms | 6.64ms | -3% |
| **P95** | 14.07ms | 12.58ms | -11% |
| **P99** | 21.99ms | 18.98ms | -14% |
| **最大延迟** | 113ms | 114ms | ≈ |
| **错误率** | 0.00% | 0.00% | = |

**结论**: Kafka 模式略优于 Channel 模式（异步写入更彻底，不占用请求协程）

---

## Redis 缓存结果（跳转：读缓存 + 续期 TTL）

本次测试运行配置：

- `KAFKA_ENABLED=false`（Channel 模式）
- `RATELIMIT_ENABLED=false`（关闭限流，避免压测被限流影响）
- 跳转解析启用 Redis 缓存（命中后会续期 TTL）

跳转测试脚本输出（`test/k6/result_redirect_redis.txt`）：

| 指标 | Redis 缓存（当前实现） |
|------|------------------------|
| **QPS** | 6,436 |
| **总请求数** | 387,310 |
| **平均延迟** | 7.04ms |
| **P50** | 6ms |
| **P95** | 14.8ms |
| **最大延迟** | 467.79ms |
| **错误率** | 0.02% |

备注：压测时关闭 tracing（`TRACING_ENABLED=false`），并使用“命中不续期”（纯 `GET`）+ 关闭 Redis AOF。

---

## 综合负载对比 (混合流量: 70%跳转 + 15%创建 + 10%认证 + 5%查询)

| 指标 | Channel 模式 | Kafka 模式 | 差异 |
|------|-------------|-----------|------|
| **QPS** | 475 | 477 | ≈ |
| **总请求数** | 66,555 | 66,748 | ≈ |
| **平均延迟** | 26.03ms | 25.77ms | -1% |
| **P95** | 101.82ms | 99.63ms | -2% |
| **错误率** | 0.00% | 0.80% | +0.8% |

**各接口延迟**:

| 接口 | Channel 模式 | Kafka 模式 |
|------|-------------|-----------|
| 跳转 (avg) | 9.6ms | 9.6ms |
| 跳转 (P95) | 48ms | 45ms |
| 创建 (avg) | 25ms | 25ms |
| 创建 (P95) | 88ms | 89ms |

**结论**: 综合场景下两者性能相近

---

## Redis 缓存结果（综合负载）

综合测试脚本输出（`test/k6/result_load_redis.txt`）：

| 指标 | Redis 缓存（当前实现） |
|------|------------------------|
| **QPS** | 399 |
| **总请求数** | 55,968 |
| **平均延迟** | 46.46ms |
| **P95** | 173.09ms |
| **错误率** | 0.00% |

备注：`http_req_failed` 为 3.05%（主要是脚本将 404 也视为“非 expected_response”，但自定义 `errors` 指标为 0%）。

---

## 关键发现

1. **跳转接口性能出色**
   - 单接口可达 **6,600+ QPS**
   - 95% 请求 < 15ms
   - 异步统计不阻塞响应

2. **Kafka vs Channel**
   - Kafka 模式延迟略低（异步更彻底）
   - Channel 模式更简单，无外部依赖
   - 对于单机部署，两者差异不大

3. **瓶颈分析**
   - 混合场景 QPS 下降是因为创建/登录涉及 DB 写入
   - 登录接口慢是因为 bcrypt（故意设计）

4. **优化空间**
   - 如果跳转缓存命中路径做到“单次 Redis 往返”，再评估跳转 QPS 提升空间
   - 创建接口可以考虑异步入库

---

## 下一步优化

1. [x] 添加 Redis 跳转缓存
2. [ ] 添加 Redis 限流
3. [ ] 再次压测对比

---

## 测试命令

```bash
# 跳转测试
k6 run test/k6/redirect_test.js

# 综合测试
k6 run test/k6/load_test.js

# 指定 Kafka 模式
KAFKA_ENABLED=true ./api.exe

# 指定 Redis 缓存压测（建议关闭限流）
RATELIMIT_ENABLED=false k6 run test/k6/redirect_test.js
RATELIMIT_ENABLED=false k6 run test/k6/load_test.js
```
